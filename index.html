<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç‹¼äººæ€ï¼šè¿·é›¾ä¹‹å¤œ (ä½“éªŒä¼˜åŒ–ç‰ˆ)</title>
    <style>
        /* å…¨å±€æ ·å¼å’Œå­—ä½“ */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --highlight-color: #fca311;
            --good-color: #2a9d8f;
            --evil-color: #e63946;
            --selectable-color: #4CAF50;
            --human-player-glow: #fca311; /* Color for human player's card */
        }

        body {
            font-family: 'Noto Serif SC', serif;
            background-color: var(--bg-color);
            /* --- UI ENHANCEMENT: Added subtle background gradient for atmosphere --- */
            background-image: radial-gradient(circle, #1a1a2e, #101020 80%);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* æ¸¸æˆä¸»å®¹å™¨ */
        #game-container {
            width: 100%;
            max-width: 1400px;
            height: 98vh;
            background: var(--primary-color);
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 2px solid var(--secondary-color);
        }
        
        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        header {
            padding: 15px 25px;
            background: var(--secondary-color);
            border-bottom: 2px solid var(--accent-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        header h1 {
            margin: 0;
            font-size: 1.6em;
            color: var(--accent-color);
            text-shadow: 0 0 8px var(--accent-color);
        }

        #game-info {
            font-size: 1.1em;
            text-align: center;
            font-weight: bold;
        }

        #rules-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #rules-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-color);
        }

        /* æ¸¸æˆä¸»åŒºåŸŸ */
        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ç©å®¶åŒºåŸŸ */
        #players-grid {
            flex: 3;
            display: grid;
            /* --- UI ENHANCEMENT: More flexible grid for small screens --- */
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            padding: 20px;
            overflow-y: auto;
            align-content: flex-start;
        }

        .player-card {
            /* --- UI ENHANCEMENT: Added gradient for depth --- */
            background-image: linear-gradient(to top, #0f3460, #16213e);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 160px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        
        /* --- UI ENHANCEMENT: Special glow for the human player's card --- */
        .player-card.human-player.alive {
            border-color: var(--human-player-glow);
            box-shadow: 0 0 15px var(--human-player-glow);
        }
        
        .player-card.alive:not(.selectable):hover {
            transform: translateY(-5px);
            border-color: var(--highlight-color);
        }

        .player-card.dead {
            opacity: 0.6;
            background: #333;
            filter: grayscale(80%);
            cursor: not-allowed;
        }
        
        .player-card.dead .player-name {
            text-decoration: line-through;
        }

        .player-card.speaking {
            border-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--accent-color);
        }
        
        .player-card.thinking {
            border-color: var(--highlight-color);
            animation: thinking-glow 1.5s infinite alternate;
        }
        
        @keyframes thinking-glow {
            from { box-shadow: 0 0 10px var(--highlight-color); }
            to { box-shadow: 0 0 30px var(--highlight-color); }
        }
        
        .player-card.selectable {
            cursor: pointer;
            border-color: var(--selectable-color);
            box-shadow: 0 0 20px var(--selectable-color);
        }
        .player-card.selectable:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--selectable-color);
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
            background-color: var(--bg-color);
            border: 3px solid var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .player-card.dead .player-avatar {
             border-color: #666;
        }
        
        .player-name {
            font-weight: bold;
            font-size: 1.2em;
        }

        .player-status {
            font-size: 0.9em;
            color: #aaa;
            min-height: 1.2em;
            font-style: italic;
        }

        /* --- UI ENHANCEMENT: Clearer display for revealed roles --- */
        .player-status.revealed-good { color: var(--good-color); font-weight: bold; }
        .player-status.revealed-evil { color: var(--evil-color); font-weight: bold; }

        .sheriff-badge, .vote-lost-badge {
            position: absolute;
            top: 5px;
            font-size: 22px;
            text-shadow: 0 0 5px black;
        }
        .sheriff-badge { left: 8px; }
        .vote-lost-badge { right: 8px; }

        /* æ—¥å¿—å’Œæ§åˆ¶åŒºåŸŸ */
        #log-control-area {
            flex: 2;
            display: flex;
            flex-direction: column;
            background: #111;
            padding: 20px;
            border-left: 2px solid var(--secondary-color);
        }

        #game-log {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid var(--secondary-color);
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-bottom: 1px dashed var(--secondary-color);
            border-radius: 4px;
        }
        
        /* --- UI ENHANCEMENT: Zebra stripes for readability --- */
        .log-entry:nth-child(odd) {
            background-color: rgba(255, 255, 255, 0.03);
        }
        
        .log-entry.system { color: var(--highlight-color); font-style: italic; }
        .log-entry.player-speech .speaker { font-weight: bold; color: var(--accent-color); }
        .log-entry.raw-log { display: none; }

        #controls {
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        #action-prompt {
            color: var(--highlight-color);
            min-height: 20px;
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .control-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 5px;
            min-width: 220px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .control-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent-color);
        }
        
        .control-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* æ¨¡æ€æ¡†æ ·å¼ */
        .modal {
            display: none;
            position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            justify-content: center; align-items: center;
            padding: 10px; box-sizing: border-box;
        }

        .modal-content {
            background-color: var(--primary-color);
            margin: auto;
            padding: 30px;
            border: 2px solid var(--accent-color);
            width: 80%;
            max-width: 800px;
            border-radius: 15px;
            position: relative;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 0 40px var(--accent-color);
        }

        .close-btn {
            color: #aaa;
            position: absolute; top: 15px; right: 25px;
            font-size: 28px; font-weight: bold; cursor: pointer;
        }
        
        .modal-content h2 { color: var(--accent-color); }
        .modal-content h3 { color: var(--highlight-color); }
        .modal-content ul { list-style-type: 'ğŸº '; padding-left: 25px;}

        /* å¤œæ™šé®ç½© */
        #night-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: none; justify-content: center; align-items: center;
            text-align: center; z-index: 50;
            font-size: 2.5em; text-shadow: 0 0 15px white;
        }

        #witch-modal-buttons {
            margin-top: 20px;
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
        }

        /* --- RESPONSIVE DESIGN FOR MOBILE --- */
        @media (max-width: 800px) {
            body {
                padding: 0;
                overflow: auto;
            }

            #game-container {
                height: 100%; min-height: 100vh;
                border-radius: 0; border: none;
            }

            header { padding: 10px 15px; }
            header h1 { font-size: 1.2em; }
            #game-info { font-size: 1em; }

            #main-area { flex-direction: column; height: auto; }
            
            #players-grid {
                /* --- UI ENHANCEMENT: Ensure 2 columns on very narrow screens --- */
                grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
                gap: 10px;
                padding: 10px;
                flex: none;
            }
            
             .player-card { min-height: 140px; padding: 10px; }
             .player-name { font-size: 1.1em; }
             .player-avatar { width: 50px; height: 50px; font-size: 1.8em; }
            
            #log-control-area {
                border-left: none;
                border-top: 2px solid var(--secondary-color);
                padding: 10px;
                flex: none;
                max-height: 45vh; /* Adjusted height */
            }
            
            #game-log { margin-bottom: 10px; }
            #controls { height: 90px; }
            .control-btn { font-size: 1.1em; min-width: 180px; }
            #action-prompt { font-size: 1.1em; }

            .modal-content {
                width: 95%; max-height: 90vh; padding: 20px;
            }
            
            #night-overlay { font-size: 2em; }
        }

    </style>
</head>
<body>

    <!-- HTML structure remains the same -->
    <div id="game-container">
        <header>
            <h1>AIç‹¼äººæ€ï¼šè¿·é›¾ä¹‹å¤œ</h1>
            <div id="game-info">ç¬¬ 1 å¤© - ç™½å¤©</div>
            <button id="rules-btn">æ¸¸æˆè§„åˆ™</button>
        </header>

        <main id="main-area">
            <div id="players-grid"></div>
            <div id="log-control-area">
                <div id="game-log">
                    <div class="log-entry system">æ¬¢è¿æ¥åˆ°è¿·é›¾ä¹‹å¤œ... æ¸¸æˆå³å°†å¼€å§‹ã€‚</div>
                </div>
                <div id="controls">
                    <div id="action-prompt"></div>
                    <button id="action-btn" class="control-btn">å¼€å§‹æ¸¸æˆ</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals (Rules, Role, Witch) -->
    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-rules">Ã—</span>
            <h2>æ¸¸æˆè§„åˆ™ä¸è§’è‰²ä»‹ç»</h2>
            <h3>èƒœåˆ©æ¡ä»¶</h3>
            <ul>
                <li><strong>å¥½äººé˜µè¥ï¼š</strong>æŠ•ç¥¨æ”¾é€æ‰€æœ‰ç‹¼äººã€‚</li>
                <li><strong>ç‹¼äººé˜µè¥ï¼š</strong>å± æ€æ‰€æœ‰ç¥èŒè§’è‰²æˆ–æ‰€æœ‰å¹³æ°‘è§’è‰²ï¼ˆå± è¾¹ï¼‰ã€‚</li>
            </ul>
            <h3>æ¸¸æˆé…ç½® (12äººå±€)</h3>
            <ul>
                <li><strong>ç‹¼äººé˜µè¥ (4äºº):</strong> 4åæ™®é€šç‹¼äººã€‚</li>
                <li><strong>å¥½äººé˜µè¥ (8äºº):</strong> é¢„è¨€å®¶, å¥³å·«, çŒäºº, ç™½ç—´, 4åå¹³æ°‘ã€‚</li>
            </ul>
            <h3>è§’è‰²ä»‹ç»</h3>
            <h4>ç‹¼äººé˜µè¥</h4>
            <ul><li><strong>ç‹¼äºº:</strong> æ¯æ™šä¸åŒä¼´å…±åŒæ€å®³ä¸€åç©å®¶ã€‚ç™½å¤©éœ€è¦ä¼ªè£…èº«ä»½ï¼Œè¯¯å¯¼å¥½äººã€‚</li></ul>
            <h4>å¥½äººé˜µè¥ - ç¥èŒ</h4>
            <ul>
                <li><strong>é¢„è¨€å®¶:</strong> æ¯æ™šå¯ä»¥æŸ¥éªŒä¸€åç©å®¶çš„èº«ä»½ï¼ˆå¥½äºº/ç‹¼äººï¼‰ã€‚å¥½äººé˜µè¥çš„é¢†è¢–ã€‚</li>
                <li><strong>å¥³å·«:</strong> æ‹¥æœ‰ä¸€ç“¶è§£è¯å’Œä¸€ç“¶æ¯’è¯ï¼Œå„åªèƒ½ç”¨ä¸€æ¬¡ã€‚è§£è¯å¯æ•‘æ´»å½“æ™šè¢«æ€çš„ç©å®¶ï¼Œæ¯’è¯å¯æ¯’æ€ä»»æ„ç©å®¶ã€‚åŒä¸€æ™šä¸èƒ½åŒæ—¶ä½¿ç”¨ä¸¤ç“¶è¯ã€‚</li>
                <li><strong>çŒäºº:</strong> å½“è¢«ç‹¼äººæ€å®³æˆ–è¢«æŠ•ç¥¨æ”¾é€æ—¶ï¼Œå¯ä»¥å¼€æªå¸¦èµ°ä»»æ„ä¸€åç©å®¶ã€‚è¢«å¥³å·«æ¯’æ€åˆ™ä¸èƒ½å‘åŠ¨æŠ€èƒ½ã€‚</li>
                <li><strong>ç™½ç—´:</strong> è¢«æŠ•ç¥¨æ”¾é€æ—¶ï¼Œå¯ä»¥ç¿»å¼€èº«ä»½ç‰Œå…äºæ­»äº¡ï¼Œä½†ä¼šå¤±å»æŠ•ç¥¨æƒã€‚è¢«æ€æˆ–è¢«æ¯’åˆ™ç›´æ¥æ­»äº¡ã€‚</li>
            </ul>
            <h4>å¥½äººé˜µè¥ - å¹³æ°‘</h4>
            <ul><li><strong>å¹³æ°‘:</strong> æ— ç‰¹æ®ŠæŠ€èƒ½ï¼Œä¾é é€»è¾‘å’Œåˆ†ææ‰¾å‡ºç‹¼äººã€‚</li></ul>
        </div>
    </div>
    
    <div id="role-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2>ä½ çš„èº«ä»½æ˜¯...</h2>
            <h1 id="role-name" style="color: var(--accent-color); font-size: 3em;"></h1>
            <p id="role-description" style="font-size: 1.2em;"></p>
            <p id="role-goal"></p>
            <button id="close-role-modal" class="control-btn">æˆ‘æ˜ç™½äº†</button>
        </div>
    </div>

    <div id="witch-modal" class="modal">
        <div class="modal-content" id="witch-modal-content">
            <h2 id="witch-prompt-title">å¥³å·«è¯·è¡ŒåŠ¨</h2>
            <p id="witch-prompt-text"></p>
            <div id="witch-modal-buttons"></div>
        </div>
    </div>

    <div id="night-overlay"><div></div></div>

    <script>
        // --- CONFIGURATION ---
        const API_KEY = "sk-gks4lNhLAE4F5SST3ZLyHFmxRpZqtpOqbbw8QrJ16O3i6ji6"; // Kimi API Key
        const KIMI_API_URL = "https://happyapi.org/v1/chat/completions";
        
        // --- MODIFICATION: TTS Configuration ---
        const ELEVENLABS_API_KEY = "YOUR_ELEVENLABS_API_KEY"; // åŠ¡å¿…æ›¿æ¢ä¸ºä½ çš„ElevenLabs API Key
        // --- MODIFICATION: Voice ID Array ---
        const ELEVENLABS_VOICE_IDS = [
            "TX3LPaxmHKxFdv7VOQHJ",
            "4VZIsMPtgggwNg7OXbPY",
            "hkfHEbBvdQFNX4uWHqRF",
            "6MoEUz34rbRrmmyxgRm4",
            "0ZOhGcBopt9S6GBK8tnj",
            "cgSgspJ2msm6clMCkdW9"
        ];
        
        const SPEECH_DELAY = 5000; // 5ç§’å‘è¨€é—´éš”

        // --- DOM ELEMENTS ---
        const playersGrid = document.getElementById('players-grid');
        const gameLog = document.getElementById('game-log');
        const gameInfo = document.getElementById('game-info');
        const actionPrompt = document.getElementById('action-prompt');
        const actionBtn = document.getElementById('action-btn');
        const nightOverlay = document.getElementById('night-overlay');
        const rulesBtn = document.getElementById('rules-btn');
        const rulesModal = document.getElementById('rules-modal');
        const closeRulesBtn = document.getElementById('close-rules');
        const roleModal = document.getElementById('role-modal');
        const closeRoleModalBtn = document.getElementById('close-role-modal');
        const witchModal = document.getElementById('witch-modal');
        
        // --- GAME STATE ---
        let gameState = {};

        // --- ROLE DEFINITIONS ---
        const ROLES = {
            WEREWOLF: { name: 'ç‹¼äºº', team: 'evil', description: 'æ¯æ™šä¸åŒä¼´å…±åŒæ€å®³ä¸€åç©å®¶ã€‚', goal: 'ç›®æ ‡ï¼šå± æ€æ‰€æœ‰ç¥èŒæˆ–æ‰€æœ‰å¹³æ°‘ã€‚' },
            SEER: { name: 'é¢„è¨€å®¶', team: 'good', description: 'æ¯æ™šå¯ä»¥æŸ¥éªŒä¸€åç©å®¶çš„çœŸå®èº«ä»½ã€‚', goal: 'ç›®æ ‡ï¼šæ‰¾å‡ºå¹¶æ”¾é€æ‰€æœ‰ç‹¼äººã€‚' },
            WITCH: { name: 'å¥³å·«', team: 'good', description: 'æ‹¥æœ‰ä¸€ç“¶è§£è¯å’Œä¸€ç“¶æ¯’è¯ï¼Œå„åªèƒ½ç”¨ä¸€æ¬¡ã€‚', goal: 'ç›®æ ‡ï¼šæ‰¾å‡ºå¹¶æ”¾é€æ‰€æœ‰ç‹¼äººã€‚' },
            HUNTER: { name: 'çŒäºº', team: 'good', description: 'æ­»äº¡æ—¶å¯ä»¥å¼€æªå¸¦èµ°ä¸€åç©å®¶ï¼ˆè¢«æ¯’æ€é™¤å¤–ï¼‰ã€‚', goal: 'ç›®æ ‡ï¼šæ‰¾å‡ºå¹¶æ”¾é€æ‰€æœ‰ç‹¼äººã€‚' },
            IDIOT: { name: 'ç™½ç—´', team: 'good', description: 'è¢«æŠ•ç¥¨æ”¾é€æ—¶å¯ç¿»ç‰Œå…æ­»ï¼Œä½†å¤±å»æŠ•ç¥¨æƒã€‚', goal: 'ç›®æ ‡ï¼šæ‰¾å‡ºå¹¶æ”¾é€æ‰€æœ‰ç‹¼äººã€‚' },
            VILLAGER: { name: 'å¹³æ°‘', team: 'good', description: 'æ²¡æœ‰ä»»ä½•ç‰¹æ®ŠæŠ€èƒ½ï¼Œä¾é é€»è¾‘æ‰¾å‡ºç‹¼äººã€‚', goal: 'ç›®æ ‡ï¼šæ‰¾å‡ºå¹¶æ”¾é€æ‰€æœ‰ç‹¼äººã€‚' }
        };

        // --- UI MANAGER ---
        const UIManager = {
            renderPlayers() {
                playersGrid.innerHTML = '';
                gameState.players.forEach(p => {
                    const card = document.createElement('div');
                    card.className = `player-card ${p.isAlive ? 'alive' : 'dead'}`;
                    if (p.id === gameState.humanPlayerId) {
                        card.classList.add('human-player');
                    }
                    card.dataset.id = p.id;
                    
                    let badges = '';
                    if (p.id === gameState.sheriffId) badges += '<div class="sheriff-badge">â­</div>';
                    if (p.hasLostVote) badges += '<div class="vote-lost-badge">ğŸš«</div>';

                    card.innerHTML = `
                        ${badges}
                        <div class="player-avatar">${p.id}</div>
                        <div class="player-name">${p.name} ${p.id === gameState.humanPlayerId ? '(ä½ )' : ''}</div>
                        <div class="player-status">${p.isAlive ? 'å­˜æ´»' : `å‡ºå±€ (${p.deathReason || ''})`}</div>
                    `;
                    if (p.isAlive) {
                       card.addEventListener('click', () => GameManager.onPlayerClick(p.id));
                    }
                    playersGrid.appendChild(card);
                });
            },
            log(message, type = 'system') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                let rawText = '';

                if (type === 'player-speech') {
                    entry.innerHTML = `<span class="speaker">${message.speaker}:</span> ${message.text}`;
                    rawText = `${message.speaker}: ${message.text}`;
                } else {
                    entry.textContent = message;
                    rawText = `[ç³»ç»Ÿ] ${message}`;
                }
                
                const rawEntry = document.createElement('div');
                rawEntry.className = 'log-entry raw-log';
                rawEntry.textContent = rawText;
                gameLog.appendChild(rawEntry);
                
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
            },
            updateGameInfo() {
                const phaseText = {'NIGHT': 'å¤œæ™š','DAY_SPEECH': 'ç™½å¤© - å‘è¨€','DAY_VOTE': 'ç™½å¤© - æŠ•ç¥¨','END': 'æ¸¸æˆç»“æŸ'}[gameState.phase] || 'ç­‰å¾…ä¸­';
                gameInfo.textContent = `ç¬¬ ${gameState.day} å¤© - ${phaseText}`;
            },
            setActionButton(text, handler, enabled = true) {
                clearInterval(gameState.countdownInterval);
                actionBtn.textContent = text;
                actionBtn.onclick = handler;
                actionBtn.disabled = !enabled;
            },
            startCountdownButton(duration, textTemplate, callback) {
                clearInterval(gameState.countdownInterval);
                actionBtn.onclick = null;
                actionBtn.disabled = true;
                let seconds = duration;
                const updateText = () => {
                    actionBtn.textContent = textTemplate.replace('{s}', seconds);
                };
                updateText();
                gameState.countdownInterval = setInterval(() => {
                    seconds--;
                    if (seconds < 0) {
                        clearInterval(gameState.countdownInterval);
                        if (callback) callback();
                    } else {
                        updateText();
                    }
                }, 1000);
            },
            setPrompt(text) { actionPrompt.innerText = text; },
            toggleNightOverlay(show, text = '') {
                nightOverlay.style.display = show ? 'flex' : 'none';
                if(show) {
                    nightOverlay.children[0].textContent = text;
                }
            },
            highlightPlayer(playerId, className) {
                 document.querySelectorAll('.player-card').forEach(c => {
                    c.classList.remove('speaking', 'thinking');
                    if (playerId !== null && parseInt(c.dataset.id) === playerId) {
                        c.classList.add(className);
                    }
                });
            },
            setPlayerSelectable(validator) {
                document.querySelectorAll('.player-card.alive').forEach(card => {
                    const id = parseInt(card.dataset.id);
                    if (validator(id)) card.classList.add('selectable');
                });
            },
            clearSelectable() {
                document.querySelectorAll('.player-card').forEach(card => card.classList.remove('selectable'));
            },
            showWitchActionModal(promptText, buttons) {
                document.getElementById('witch-prompt-text').innerText = promptText;
                const buttonContainer = document.getElementById('witch-modal-buttons');
                buttonContainer.innerHTML = '';
                buttons.forEach(btnInfo => {
                    const btn = document.createElement('button');
                    btn.className = 'control-btn';
                    btn.innerText = btnInfo.text;
                    btn.onclick = () => {
                        witchModal.style.display = 'none';
                        btnInfo.action();
                    };
                    btn.disabled = btnInfo.disabled || false;
                    buttonContainer.appendChild(btn);
                });
                witchModal.style.display = 'flex';
            },
            showRoleModal(player) {
                document.getElementById('role-name').textContent = player.role.name;
                document.getElementById('role-description').textContent = player.role.description;
                document.getElementById('role-goal').textContent = player.role.goal;
                roleModal.style.display = 'flex';
            },
        };
        
        // --- AUDIO MANAGER ---
        const AudioManager = {
            _mediaSource: null,
            _sourceBuffer: null,
            _audioElement: null,
            _appendQueue: [],
            _isAppending: false,

            _base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            },

            _processAppendQueue() {
                if (this._isAppending || this._appendQueue.length === 0 || !this._sourceBuffer || this._sourceBuffer.updating) {
                    return;
                }
                this._isAppending = true;
                const buffer = this._appendQueue.shift();

                const onUpdateEnd = () => {
                    this._sourceBuffer.removeEventListener('updateend', onUpdateEnd);
                    this._sourceBuffer.removeEventListener('error', onError);
                    this._isAppending = false;
                    this._processAppendQueue();
                };
                const onError = (e) => {
                     console.error('SourceBuffer error on append:', e);
                     this._isAppending = false;
                }

                this._sourceBuffer.addEventListener('updateend', onUpdateEnd);
                this._sourceBuffer.addEventListener('error', onError);
                
                try {
                    this._sourceBuffer.appendBuffer(buffer);
                } catch (e) {
                    console.error("Error appending buffer:", e);
                    this._isAppending = false;
                }
            },
            
            // --- MODIFICATION: Accepts voiceId parameter ---
            playStream(text, voiceId) {

                if (!voiceId) {
                    GameManager.internalLog("æœªæä¾›éŸ³è‰²IDï¼Œè·³è¿‡TTSã€‚");
                    return Promise.resolve();
                }
                
                // --- MODIFICATION: Dynamic URL construction ---
                const ttsUrl = `https://kimi.akpcmyqk.workers.dev/v1/text-to-speech/${voiceId}/stream/with-timestamps?allow_unauthenticated=1`;


                return new Promise(async (resolve, reject) => {
                    this._mediaSource = new MediaSource();
                    this._audioElement = new Audio();
                    this._audioElement.src = URL.createObjectURL(this._mediaSource);
                    this._appendQueue = [];
                    this._isAppending = false;

                    this._mediaSource.addEventListener('sourceopen', async () => {
                        URL.revokeObjectURL(this._audioElement.src);
                        try {
                            this._sourceBuffer = this._mediaSource.addSourceBuffer('audio/mpeg');

                            const response = await fetch(ttsUrl, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    text: text,
                                    model_id: "eleven_turbo_v2_5",
                                    voice_settings: { speed: 1.0 }
                                }),
                            });

                            if (!response.ok) {
                                const errorBody = await response.text();
                                throw new Error(`TTS API é”™è¯¯: ${response.status} ${response.statusText} - ${errorBody}`);
                            }

                            const reader = response.body.getReader();
                            const decoder = new TextDecoder();
                            let buffer = '';

                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) {
                                    if (buffer.length > 0) {
                                       try {
                                           const chunk = JSON.parse(buffer);
                                           if (chunk.audio_base64) {
                                               const audioChunk = this._base64ToArrayBuffer(chunk.audio_base64);
                                               this._appendQueue.push(audioChunk);
                                               this._processAppendQueue();
                                           }
                                       } catch (e) {
                                            console.warn('æ— æ³•è§£ææœ€åçš„JSONå—:', buffer);
                                       }
                                    }
                                    break;
                                }
                                
                                buffer += decoder.decode(value, { stream: true });
                                const lines = buffer.split('\n');
                                buffer = lines.pop(); 

                                for (const line of lines) {
                                    if (line.trim() === '') continue;
                                    try {
                                        const chunk = JSON.parse(line);
                                        if (chunk.audio_base64) {
                                            const audioChunk = this._base64ToArrayBuffer(chunk.audio_base64);
                                            this._appendQueue.push(audioChunk);
                                            this._processAppendQueue();
                                        }
                                    } catch (e) {
                                        console.warn("æ— æ³•è§£æJSONè¡Œ:", line, e);
                                    }
                                }
                            }
                            
                            const checkQueueAndEnd = () => {
                                if (!this._isAppending && this._appendQueue.length === 0) {
                                    if (this._mediaSource.readyState === 'open') {
                                        this._mediaSource.endOfStream();
                                    }
                                } else {
                                    setTimeout(checkQueueAndEnd, 100);
                                }
                            };
                            checkQueueAndEnd();

                        } catch (error) {
                            console.error("TTSæµå¼ä¼ è¾“æœŸé—´å‡ºé”™:", error);
                            if (this._mediaSource && this._mediaSource.readyState === 'open') {
                                this._mediaSource.endOfStream();
                            }
                            reject(error);
                        }
                    });

                    this._audioElement.addEventListener('ended', resolve);
                    this._audioElement.addEventListener('error', (e) => {
                        console.error('éŸ³é¢‘å…ƒç´ é”™è¯¯:', this._audioElement.error);
                        reject(this._audioElement.error);
                    });
                    
                    try {
                        await this._audioElement.play();
                    } catch(e) {
                        console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", e);
                        reject(e);
                    }
                });
            }
        };

        // --- AI LOGIC (INTELLIGENT) ---
        const AILogic = {
            _buildContext(player, state) {
                let context = `# æ¸¸æˆèƒŒæ™¯\n- æ¸¸æˆé…ç½®: 4ç‹¼, 4æ°‘, é¢„è¨€å®¶, å¥³å·«, çŒäºº, ç™½ç—´ã€‚\n- èƒœåˆ©æ¡ä»¶: ç‹¼äººå± è¾¹(æ€å…‰ç¥æˆ–æ°‘)ï¼Œå¥½äººæ”¾é€æ‰€æœ‰ç‹¼äººã€‚\n\n`;
                context += `# ä½ çš„èº«ä»½ä¿¡æ¯\n- ä½ çš„ç¼–å·: ${player.id}å·\n- ä½ çš„èº«ä»½: ${player.role.name}\n- ä½ çš„é˜µè¥: ${player.role.team === 'good' ? 'å¥½äºº' : 'ç‹¼äºº'}\n- ä½ çš„ç›®æ ‡: ${player.role.goal}\n\n`;
                
                context += `# ä½ çš„ç‰¹æ®Šä¿¡æ¯ (ä»…è‡ªå·±å¯è§)\n`;
                let specialInfo = [];
                if (player.role.name === 'ç‹¼äºº') {
                    const wolfMates = state.players.filter(p => p.role.name === 'ç‹¼äºº' && p.id !== player.id).map(p => `${p.id}å·`).join(', ');
                    specialInfo.push(`ä½ çš„ç‹¼é˜Ÿå‹æ˜¯: ${wolfMates}`);
                }
                if (player.role.name === 'é¢„è¨€å®¶' && player.memory.checked.length > 0) {
                    const checks = player.memory.checked.map(c => `${c.id}å·æ˜¯${c.isWolf ? 'ç‹¼äºº' : 'å¥½äºº'}`).join('; ');
                    specialInfo.push(`ä½ æŸ¥éªŒè¿‡: ${checks}`);
                }
                if (player.role.name === 'å¥³å·«') {
                    specialInfo.push(`è§£è¯çŠ¶æ€: ${state.witchHasAntidote ? 'å¯ç”¨' : 'å·²ç”¨'}`);
                    specialInfo.push(`æ¯’è¯çŠ¶æ€: ${state.witchHasPoison ? 'å¯ç”¨' : 'å·²ç”¨'}`);
                }
                if (specialInfo.length > 0) {
                    context += specialInfo.join('\n') + '\n\n';
                } else {
                    context += `- ä½ æ²¡æœ‰é¢å¤–çš„ç‰¹æ®Šä¿¡æ¯ã€‚\n\n`;
                }

                context += `# å½“å‰æ¸¸æˆçŠ¶æ€\n- ä»Šå¤©æ˜¯ç¬¬ ${state.day} å¤©\n- è­¦é•¿: ${state.sheriffId > 0 ? `${state.sheriffId}å·` : 'æ— '}\n`;
                const alivePlayers = state.players.filter(p => p.isAlive);
                const alivePlayerIds = alivePlayers.map(p => `${p.id}å·`).join(', ');
                context += `- å­˜æ´»ç©å®¶ (${alivePlayers.length}äºº): ${alivePlayerIds}\n`;
                const deadPlayers = state.players.filter(p => !p.isAlive);
                if (deadPlayers.length > 0) {
                    const deadInfo = deadPlayers.map(p => `${p.id}å·(${p.hasFlipped ? p.role.name : 'æœªçŸ¥èº«ä»½'}) - ${p.deathReason}`).join('; ');
                    context += `- å‡ºå±€ç©å®¶ä¿¡æ¯: ${deadInfo}\n`;
                } else {
                    context += `- å‡ºå±€ç©å®¶ä¿¡æ¯: æ— \n`;
                }

                context += `\n# æ¸¸æˆæ—¥å¿— (æŒ‰æ—¶é—´é¡ºåº)\n`;
                const logNodes = gameLog.querySelectorAll('.raw-log');
                const logHistory = Array.from(logNodes).map(node => node.textContent).join('\n');
                context += logHistory;
                return context;
            },
            async _callAPI(system_prompt, user_prompt) {
                if (!API_KEY || API_KEY.includes("xxx")) {
                    GameManager.internalLog("API_KEY æœªé…ç½®ï¼å°†ä½¿ç”¨éšæœºå†³ç­–ã€‚");
                    return null;
                }
                try {
                    const response = await fetch(KIMI_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${API_KEY}`
                        },
                        body: JSON.stringify({
                            model: 'kimi-k2-0711-preview',
                            messages: [
                                { "role": "system", "content": system_prompt },
                                { "role": "user", "content": user_prompt }
                            ],
                            temperature: 0.7,
                            max_tokens: 16000,
                        })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API Error: ${response.status} - ${errorData.error.message}`);
                    }
                    const data = await response.json();
                    return data.choices[0].message.content.trim();
                } catch (error) {
                    console.error("è°ƒç”¨AIå†³ç­–APIæ—¶å‡ºé”™:", error);
                    GameManager.internalLog(`APIè¯·æ±‚å¤±è´¥: ${error.message}`);
                    return null;
                }
            },
            async generateSpeech(player, state) {
                GameManager.internalLog(`æ­£åœ¨ä¸º ${player.id}å· (${player.role.name}) ç”Ÿæˆå‘è¨€...`);
                const system_prompt = `ä½ æ­£åœ¨ä¸€ä¸ª12äººåˆ¶çš„åœ¨çº¿AIç‹¼äººæ€æ¸¸æˆä¸­æ‰®æ¼”ä¸€åç©å®¶ã€‚ä½ çš„å‘è¨€åº”è¯¥ç¬¦åˆä½ çš„èº«ä»½å’Œç›®æ ‡ã€‚è¯·ä¸è¦åœ¨å‘è¨€ä¸­æš´éœ²ä½ æ˜¯AIæˆ–æåŠâ€œæ ¹æ®æˆ‘çš„åˆ†æâ€ã€‚ä½ çš„å‘è¨€åº”è¯¥ç®€çŸ­ã€æœ‰è¯´æœåŠ›ï¼Œå¹¶ä¸”ç¬¦åˆå½“å‰æ¸¸æˆæƒ…å¢ƒã€‚è¯·ç›´æ¥è¾“å‡ºä½ çš„å‘è¨€å†…å®¹ï¼Œä¸è¦åŒ…å«ä»»ä½•å‰ç¼€ï¼Œä¾‹å¦‚â€œå‘è¨€ï¼šâ€æˆ–â€œå¥½çš„ï¼Œè¿™æ˜¯æˆ‘çš„å‘è¨€ï¼šâ€ã€‚`;
                const context = this._buildContext(player, state);
                const user_prompt = `${context}\n\n# ä½ çš„ä»»åŠ¡\nç°åœ¨è½®åˆ°ä½  (${player.id}å·) å‘è¨€ã€‚è¯·æ ¹æ®ä»¥ä¸Šæ‰€æœ‰ä¿¡æ¯ï¼Œç”Ÿæˆä¸€æ®µæœ‰è¯´æœåŠ›çš„ã€ç¬¦åˆä½ èº«ä»½çš„ç®€çŸ­å‘è¨€ã€‚`;
                
                const speech = await this._callAPI(system_prompt, user_prompt);
                
                if (speech) {
                    GameManager.internalLog(`APIä¸º ${player.id}å· è¿”å›å‘è¨€: "${speech}"`);
                    return speech;
                } else {
                    return "æˆ‘...æˆ‘éœ€è¦å†æƒ³ä¸€æƒ³ã€‚è¿‡ã€‚";
                }
            },
            async getAIActionDecision(player, state, decision_prompt, valid_options) {
                GameManager.internalLog(`æ­£åœ¨ä¸º ${player.id}å· (${player.role.name}) è·å–å†³ç­–: ${decision_prompt}`);
                const system_prompt = `ä½ æ˜¯ä¸€ä¸ªç‹¼äººæ€AIç©å®¶ï¼Œä½ éœ€è¦æ ¹æ®å½“å‰å±€åŠ¿åšå‡ºæœ€åˆç†çš„å†³ç­–ã€‚è¯·ä¸¥æ ¼æŒ‰ç…§è¦æ±‚ï¼Œåªè¾“å‡ºä¸€ä¸ªæœ€ç»ˆé€‰æ‹©ï¼Œä¸è¦åŒ…å«ä»»ä½•å¤šä½™çš„æ–‡å­—æˆ–è§£é‡Šã€‚`;
                const context = this._buildContext(player, state);
                const user_prompt = `${context}\n\n# ä½ çš„ä»»åŠ¡\n${decision_prompt}\n\nä½ çš„é€‰æ‹©å¿…é¡»æ˜¯ä»¥ä¸‹é€‰é¡¹ä¹‹ä¸€: [${valid_options.join(', ')}]\n\nè¯·ç›´æ¥è¾“å‡ºä½ é€‰æ‹©çš„é‚£ä¸ªæ•°å­—æˆ–å•è¯:`;
                
                const decision = await this._callAPI(system_prompt, user_prompt);
                
                if (decision) {
                    GameManager.internalLog(`APIä¸º ${player.id}å· è¿”å›å†³ç­–: "${decision}"`);
                    const choice = (decision.match(/\d+/) || [null])[0];
                    const parsedChoice = parseInt(choice, 10);
                    if (valid_options.includes(parsedChoice)) {
                        return parsedChoice;
                    }
                    const keywordChoice = decision.toUpperCase();
                    if (valid_options.includes(keywordChoice)) {
                        return keywordChoice;
                    }
                }
                
                GameManager.internalLog(`AIå†³ç­–å¤±è´¥æˆ–æ— æ•ˆï¼Œå°†ä½¿ç”¨éšæœºåå¤‡æ–¹æ¡ˆã€‚`);
                return valid_options[Math.floor(Math.random() * valid_options.length)];
            }
        };

        // --- GAME MANAGER ---
        const GameManager = {
            init() {
                actionBtn.onclick = this.startGame.bind(this);
                rulesBtn.onclick = () => { rulesModal.style.display = 'flex'; };
                closeRulesBtn.onclick = () => { rulesModal.style.display = 'none'; };
                this.internalLog("æ¸¸æˆç®¡ç†å™¨åˆå§‹åŒ–ã€‚");
            },
            internalLog(message) {
                console.log(`%c[å†…éƒ¨æ—¥å¿—] %c${new Date().toLocaleTimeString()}: %c${message}`, "color: #1e90ff; font-weight: bold;", "color: #777;", "color: #333;");
            },
            async startGame() {
                let roles = [ROLES.WEREWOLF, ROLES.WEREWOLF, ROLES.WEREWOLF, ROLES.WEREWOLF, ROLES.SEER, ROLES.WITCH, ROLES.HUNTER, ROLES.IDIOT, ROLES.VILLAGER, ROLES.VILLAGER, ROLES.VILLAGER, ROLES.VILLAGER];
                for (let i = roles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [roles[i], roles[j]] = [roles[j], roles[i]];
                }
                gameState = {
                    day: 1, phase: 'INIT', players: [], humanPlayerId: -1, sheriffId: -1, nightInfo: {},
                    witchHasAntidote: true, witchHasPoison: true, isWaitingForHumanAction: false,
                    humanActionResolver: null, humanActionValidator: null, countdownInterval: null, votes: {},
                };
                const names = ["çˆ±ä¸½ä¸", "é²å‹ƒ", "æŸ¥ç†", "æˆ´å¤«", "ä¼ŠèŠ™", "å¼—å…°å…‹", "æ ¼è•¾ä¸", "æµ·è’‚", "ä¼Šä¸‡", "æœ±è¿ª", "é©¬æ´›é‡Œ", "å¥¥æ–¯å¡"];
                for (let i = 0; i < 12; i++) {
                    // --- MODIFICATION: Assign a random voiceId to each player ---
                    const assignedVoiceId = ELEVENLABS_VOICE_IDS[Math.floor(Math.random() * ELEVENLABS_VOICE_IDS.length)];
                    gameState.players.push({
                        id: i + 1, name: names[i], role: roles[i], isAlive: true, isHuman: false,
                        voiceId: assignedVoiceId, // Add voiceId property
                        memory: { checked: [] }, hasFlipped: false, hasLostVote: false, deathReason: ''
                    });
                }
                this.internalLog("--- èº«ä»½åˆ†é…å®Œæ¯• ---");
                gameState.players.forEach(p => this.internalLog(`${p.id}å· ${p.name}: ${p.role.name} (éŸ³è‰²: ${p.voiceId})`));
                
                gameState.humanPlayerId = Math.floor(Math.random() * 12) + 1;
                const humanPlayer = gameState.players.find(p => p.id === gameState.humanPlayerId);
                humanPlayer.isHuman = true;
                this.internalLog(`ç©å®¶è¢«åˆ†é…ä¸º ${gameState.humanPlayerId}å· (${humanPlayer.role.name})`);
                
                UIManager.renderPlayers();
                UIManager.showRoleModal(humanPlayer);
                UIManager.setActionButton("è¯·å…³é—­èº«ä»½å¡å¼€å§‹æ¸¸æˆ", null, false);
                closeRoleModalBtn.onclick = () => {
                    roleModal.style.display = 'none';
                    this.startNight();
                };
            },
            async startNight() {
                gameState.phase = 'NIGHT';
                this.internalLog(`--- å¤œæ™š ${gameState.day} å¼€å§‹ ---`);
                UIManager.updateGameInfo();
                UIManager.toggleNightOverlay(true, `ç¬¬ ${gameState.day} å¤© - å¤œæ™š`);
                gameState.nightInfo = { wolfTarget: null, seerCheck: { target: null, result: null }, witchSave: false, witchPoison: null, finalDeaths: [] };

                await this.timeout(1500); await this.handleWolfAction();
                await this.timeout(1500); await this.handleSeerAction();
                await this.timeout(1500); await this.handleWitchAction();
                
                await this.timeout(2000);
                this.processNightResults();
                this.startDay();
            },
            async waitForHumanSelection(prompt, validator) {
                UIManager.toggleNightOverlay(false); 
                return new Promise(resolve => {
                    gameState.isWaitingForHumanAction = true;
                    gameState.humanActionResolver = resolve;
                    gameState.humanActionValidator = validator;
                    UIManager.setPrompt(prompt);
                    UIManager.setPlayerSelectable(validator);
                });
            },
            async handleWolfAction() {
                UIManager.toggleNightOverlay(true, 'ç‹¼äººè¯·è¡ŒåŠ¨...');
                const humanWolf = gameState.players.find(p => p.isHuman && p.isAlive && p.role.name === 'ç‹¼äºº');
                let targetId = null;
                if (humanWolf) {
                    targetId = await this.waitForHumanSelection('è¯·é€‰æ‹©ä½ è¦å‡»æ€çš„ç›®æ ‡', (id) => id !== humanWolf.id && gameState.players.find(p => p.id === id).isAlive);
                    this.internalLog(`ç©å®¶(ç‹¼äºº)é€‰æ‹©äº†æ”»å‡» ${targetId}å·`);
                } else {
                    const wolves = gameState.players.filter(p => p.role.name === 'ç‹¼äºº' && p.isAlive);
                    if (wolves.length > 0) {
                        const aiWolf = wolves[0];
                        UIManager.highlightPlayer(aiWolf.id, 'thinking');
                        const validTargets = gameState.players.filter(p => p.isAlive && p.role.team === 'good').map(p => p.id);
                        if(validTargets.length > 0) {
                            const prompt = `ä½ æ˜¯ç‹¼äººï¼Œè¯·é€‰æ‹©ä¸€ä¸ªç›®æ ‡è¿›è¡Œå‡»æ€ã€‚ä¼˜å…ˆè€ƒè™‘å‡»æ€ç¥èŒï¼ˆé¢„è¨€å®¶ã€å¥³å·«ã€çŒäººï¼‰æˆ–çœ‹èµ·æ¥åƒé¢†è¢–çš„ç©å®¶ã€‚`;
                            targetId = await AILogic.getAIActionDecision(aiWolf, gameState, prompt, validTargets);
                            this.internalLog(`AIç‹¼äººå›¢é˜Ÿé€‰æ‹©æ”»å‡» ${targetId}å·`);
                        }
                        UIManager.highlightPlayer(null);
                    }
                }
                gameState.nightInfo.wolfTarget = targetId;
                UIManager.setPrompt(''); UIManager.clearSelectable();
            },
            async handleSeerAction() {
                UIManager.toggleNightOverlay(true, 'é¢„è¨€å®¶è¯·è¡ŒåŠ¨...');
                const seer = gameState.players.find(p => p.isAlive && p.role.name === 'é¢„è¨€å®¶');
                if (!seer) return;

                let targetId;
                if (seer.isHuman) {
                    targetId = await this.waitForHumanSelection('è¯·é€‰æ‹©ä½ è¦æŸ¥éªŒçš„ç›®æ ‡', (id) => id !== seer.id);
                } else {
                    UIManager.highlightPlayer(seer.id, 'thinking');
                    const uncheckedPlayers = gameState.players.filter(p => p.isAlive && p.id !== seer.id && !seer.memory.checked.some(c => c.id === p.id)).map(p => p.id);
                    const validTargets = uncheckedPlayers.length > 0 ? uncheckedPlayers : gameState.players.filter(p=>p.isAlive && p.id !== seer.id).map(p=>p.id);
                    const prompt = `ä½ æ˜¯é¢„è¨€å®¶ï¼Œè¯·é€‰æ‹©ä¸€ä¸ªä½ è®¤ä¸ºæœ€å¯ç–‘çš„ã€ä¸”æœªæŸ¥éªŒè¿‡çš„ç©å®¶è¿›è¡ŒæŸ¥éªŒã€‚`;
                    targetId = await AILogic.getAIActionDecision(seer, gameState, prompt, validTargets);
                    UIManager.highlightPlayer(null);
                }

                if (targetId) {
                    const targetPlayer = gameState.players.find(p => p.id === targetId);
                    const isWolf = targetPlayer.role.team === 'evil';
                    seer.memory.checked.push({ id: targetId, isWolf });
                    this.internalLog(`é¢„è¨€å®¶ (${seer.isHuman ? 'ç©å®¶' : 'AI'}) æŸ¥éªŒäº† ${targetId}å·, ç»“æœæ˜¯ ${isWolf ? 'ç‹¼äºº' : 'å¥½äºº'}`);
                    if (seer.isHuman) {
                        alert(`æŸ¥éªŒç»“æœï¼š${targetId}å·ç©å®¶æ˜¯ã€${isWolf ? 'ç‹¼äºº' : 'å¥½äºº'}ã€‘`);
                    }
                }
                UIManager.setPrompt(''); UIManager.clearSelectable();
            },
            async handleWitchAction() {
                UIManager.toggleNightOverlay(true, 'å¥³å·«è¯·è¡ŒåŠ¨...');
                const witch = gameState.players.find(p => p.isAlive && p.role.name === 'å¥³å·«');
                if (!witch) return;

                const attackedId = gameState.nightInfo.wolfTarget;
                const canSave = gameState.witchHasAntidote && attackedId !== null;
                const canPoison = gameState.witchHasPoison;

                if (witch.isHuman) {
                    let usedAntidoteThisNight = false;
                    if (canSave) {
                        const savePromise = new Promise(resolve => {
                            UIManager.showWitchActionModal(
                                `ä»Šæ™š ${attackedId} å·ç©å®¶è¢«æ”»å‡»äº†ã€‚ä½ è¦ä½¿ç”¨è§£è¯å—ï¼Ÿ`,
                                [
                                    { text: 'ä½¿ç”¨è§£è¯', action: () => resolve(true) },
                                    { text: 'ä¸ä½¿ç”¨', action: () => resolve(false) }
                                ]
                            );
                        });
                        if (await savePromise) {
                            gameState.nightInfo.witchSave = true;
                            gameState.witchHasAntidote = false;
                            usedAntidoteThisNight = true;
                            this.internalLog(`ç©å®¶(å¥³å·«)ä½¿ç”¨äº†ã€è§£è¯ã€‘`);
                        }
                    }
                    if (canPoison && !usedAntidoteThisNight) {
                        const poisonPromise = new Promise(resolve => {
                            UIManager.showWitchActionModal('ä½ è¦ä½¿ç”¨æ¯’è¯å—ï¼Ÿ', [
                                { text: 'ä½¿ç”¨æ¯’è¯', action: () => resolve(true) },
                                { text: 'ä¸ä½¿ç”¨', action: () => resolve(false) }
                            ]);
                        });
                        if (await poisonPromise) {
                            const targetId = await this.waitForHumanSelection('è¯·é€‰æ‹©ä½ è¦æ¯’æ€çš„ç›®æ ‡', (id) => id !== witch.id && gameState.players.find(p => p.id === id).isAlive);
                            gameState.nightInfo.witchPoison = targetId;
                            gameState.witchHasPoison = false;
                            this.internalLog(`ç©å®¶(å¥³å·«)å¯¹ ${targetId}å· ä½¿ç”¨äº†ã€æ¯’è¯ã€‘`);
                        }
                    }
                } else { // AI Witch Logic
                    UIManager.highlightPlayer(witch.id, 'thinking');
                    const simplifiedPrompt = `ä½ æ˜¯å¥³å·«ã€‚ä»Šæ™š${attackedId ? ` ${attackedId}å·è¢«æ”»å‡»äº†` : 'æ˜¯å¹³å®‰å¤œ'}ã€‚ä½ çš„è§£è¯${canSave ? 'å¯ç”¨' : 'å·²ç”¨'}ï¼Œæ¯’è¯${canPoison ? 'å¯ç”¨' : 'å·²ç”¨'}ã€‚æ ¹æ®åœºä¸Šä¿¡æ¯å’Œä½ çš„åˆ¤æ–­ï¼Œåšå‡ºä½ çš„é€‰æ‹©ã€‚`;
                    const simplifiedOptions = ['SKIP'];
                    if (canSave) simplifiedOptions.push('SAVE');
                    if (canPoison) {
                        const poisonTargets = gameState.players.filter(p => p.isAlive && p.id !== witch.id && p.id !== attackedId).map(p=>p.id);
                        if(poisonTargets.length > 0) simplifiedOptions.push('POISON');
                    }
                    
                    const decision = await AILogic.getAIActionDecision(witch, gameState, simplifiedPrompt, simplifiedOptions);
                    
                    if (decision === 'SAVE' && canSave) {
                         gameState.nightInfo.witchSave = true;
                         gameState.witchHasAntidote = false;
                         this.internalLog(`AIå¥³å·«å†³å®šã€ä½¿ç”¨è§£è¯ã€‘æ‹¯æ•‘${attackedId}å·ã€‚`);
                    } else if (decision === 'POISON' && canPoison) {
                        const poisonPrompt = `ä½ å·²å†³å®šä½¿ç”¨æ¯’è¯ï¼Œè¯·é€‰æ‹©ä¸€ä¸ªä½ è®¤ä¸ºæœ€åƒç‹¼äººçš„ç©å®¶è¿›è¡Œæ¯’æ€ã€‚`;
                        const poisonTargets = gameState.players.filter(p=>p.isAlive && p.id !== witch.id && p.id !== attackedId).map(p=>p.id);
                        if (poisonTargets.length > 0) {
                            const targetId = await AILogic.getAIActionDecision(witch, gameState, poisonPrompt, poisonTargets);
                            gameState.nightInfo.witchPoison = targetId;
                            gameState.witchHasPoison = false;
                            this.internalLog(`AIå¥³å·«å†³å®šã€ä½¿ç”¨æ¯’è¯ã€‘æ¯’æ€${targetId}å·ã€‚`);
                        }
                    } else {
                        this.internalLog(`AIå¥³å·«å†³å®šã€è·³è¿‡ã€‘ã€‚`);
                    }
                    UIManager.highlightPlayer(null);
                }
                UIManager.setPrompt(''); UIManager.clearSelectable();
            },
            processNightResults() {
                const { wolfTarget, witchSave, witchPoison } = gameState.nightInfo;
                let finalDeaths = [];
                if (witchPoison !== null) finalDeaths.push({ id: witchPoison, reason: 'è¢«æ¯’æ€' });
                if (wolfTarget !== null && !witchSave && wolfTarget !== witchPoison) {
                    finalDeaths.push({ id: wolfTarget, reason: 'è¢«ç‹¼äººæ€å®³' });
                }
                gameState.nightInfo.finalDeaths = finalDeaths;
                this.internalLog(`å¤œæ™šç»“ç®—ï¼šæœ€ç»ˆæ­»äº¡: ${finalDeaths.map(d => `${d.id}å·`).join(', ') || 'æ— '}`);
            },
            async startDay() {
                UIManager.toggleNightOverlay(false);
                const deaths = gameState.nightInfo.finalDeaths;
                if (deaths.length > 0) {
                    UIManager.log(`å¤©äº®äº†ã€‚æ˜¨æ™š, ${deaths.map(d=>d.id).join('å·å’Œ')}å·ç©å®¶æ­»äº¡äº†ã€‚`);
                    for (const death of deaths) await this.killPlayer(death.id, death.reason);
                } else {
                    UIManager.log(`å¤©äº®äº†ã€‚æ˜¨æ™šæ˜¯ä¸€ä¸ªå¹³å®‰å¤œã€‚`);
                }
                UIManager.renderPlayers();
                if (this.checkWinCondition()) return;
                gameState.phase = 'DAY_SPEECH';
                UIManager.updateGameInfo();
                gameState.currentSpeakerIndex = 0;
                this.nextSpeech();
            },
            async nextSpeech() {
                const alivePlayers = gameState.players.filter(p => p.isAlive);
                if (gameState.currentSpeakerIndex >= alivePlayers.length) {
                    UIManager.highlightPlayer(null); this.startVote(); return;
                }
                const speaker = alivePlayers[gameState.currentSpeakerIndex];
                UIManager.highlightPlayer(speaker.id, 'speaking');
                UIManager.log(`${speaker.id}å·ç©å®¶å¼€å§‹å‘è¨€...`);
                
                if (speaker.isHuman) {
                    const speech = prompt("è½®åˆ°ä½ å‘è¨€ï¼Œè¯·è¾“å…¥ï¼š", "æˆ‘æ˜¯ä¸ªå¥½äººï¼Œè¯·ç›¸ä¿¡æˆ‘ã€‚");
                    const displayName = `${speaker.id}å·ç©å®¶ (ä½ )`;
                    UIManager.log({ speaker: displayName, text: speech || '(è¿‡éº¦)' }, 'player-speech');
                    UIManager.startCountdownButton(SPEECH_DELAY / 1000, "ä¸‹ä¸€ä½å‘è¨€ ({s}s)", () => {
                         gameState.currentSpeakerIndex++;
                         this.nextSpeech();
                    });
                } else {
                    UIManager.highlightPlayer(speaker.id, 'thinking');
                    UIManager.setActionButton("AIæ­£åœ¨ç”Ÿæˆå‘è¨€...", null, false);
                    const speech = await AILogic.generateSpeech(speaker, gameState);
                    
                    UIManager.highlightPlayer(speaker.id, 'speaking');
                    const displayName = `${speaker.id}å·ç©å®¶`;
                    UIManager.log({ speaker: displayName, text: speech || '(è¿‡éº¦)' }, 'player-speech');

                    UIManager.setActionButton("AIæ­£åœ¨å‘è¨€...", null, false);
                    // --- MODIFICATION: Pass the speaker's voiceId to the AudioManager ---
                    await AudioManager.playStream(speech, speaker.voiceId).catch(err => {
                        this.internalLog(`æ— æ³•æ’­æ”¾éŸ³é¢‘, å°†ç›´æ¥è¿›å…¥å»¶æ—¶: ${err}`);
                    });

                    UIManager.startCountdownButton(SPEECH_DELAY / 1000, "ä¸‹ä¸€ä½å‘è¨€ ({s}s)", () => {
                        gameState.currentSpeakerIndex++;
                        this.nextSpeech();
                    });
                }
            },
            startVote() {
                gameState.phase = 'DAY_VOTE';
                UIManager.updateGameInfo();
                UIManager.log("å‘è¨€ç»“æŸï¼Œç°åœ¨å¼€å§‹æŠ•ç¥¨ã€‚");
                gameState.votes = {};
                const humanPlayer = gameState.players.find(p => p.id === gameState.humanPlayerId);
                if (humanPlayer && humanPlayer.isAlive && !humanPlayer.hasLostVote) {
                    UIManager.setPrompt("è¯·ç‚¹å‡»ä½ è¦æŠ•ç¥¨çš„ç©å®¶å¤´åƒã€‚");
                    UIManager.setActionButton("ç­‰å¾…ä½ çš„æŠ•ç¥¨...", null, false);
                    UIManager.setPlayerSelectable((id) => gameState.players.find(p => p.id === id).isAlive && id !== humanPlayer.id);
                } else {
                    UIManager.setActionButton("AIæ­£åœ¨æŠ•ç¥¨...", null, false);
                    this.processAIVotes();
                }
            },
            async processAIVotes() {
                const aiVoters = gameState.players.filter(p => p.isAlive && !p.isHuman && !p.hasLostVote);
                for(const voter of aiVoters) {
                    UIManager.highlightPlayer(voter.id, 'thinking');
                    await this.timeout(200);
                    const validTargets = gameState.players.filter(p => p.isAlive && p.id !== voter.id).map(p => p.id);
                    if (validTargets.length > 0) {
                        const prompt = `ç°åœ¨æ˜¯æŠ•ç¥¨ç¯èŠ‚ï¼Œè¯·æ ¹æ®åœºä¸Šæ‰€æœ‰äººçš„å‘è¨€å’Œä¿¡æ¯ï¼ŒæŠ•ç¥¨ç»™ä½ è®¤ä¸ºæœ€åƒç‹¼äººçš„ç©å®¶ã€‚`;
                        const voteTarget = await AILogic.getAIActionDecision(voter, gameState, prompt, validTargets);
                        if (voteTarget) this.castVote(voter.id, voteTarget);
                    }
                    UIManager.highlightPlayer(null);
                }
                this.tallyVotes();
            },
            castVote(voterId, targetId) {
                if (!gameState.votes[targetId]) gameState.votes[targetId] = [];
                gameState.votes[targetId].push(voterId);
                this.internalLog(`ç©å®¶ ${voterId}å· æŠ•ç¥¨ç»™ ${targetId}å·ã€‚`);
            },
            async tallyVotes() {
                UIManager.clearSelectable();
                UIManager.setPrompt('');
                let maxVotes = 0; let tiedPlayers = [];
                UIManager.log("--- æŠ•ç¥¨ç»“æœ ---");
                for (const targetId in gameState.votes) {
                    const voteCount = gameState.votes[targetId].length;
                    UIManager.log(`${targetId}å·: ${voteCount}ç¥¨ (${gameState.votes[targetId].join(', ')}å·æŠ•)`);
                    if (voteCount > maxVotes) { maxVotes = voteCount; tiedPlayers = [parseInt(targetId)]; }
                    else if (voteCount === maxVotes) { tiedPlayers.push(parseInt(targetId)); }
                }
                if (tiedPlayers.length === 1 && maxVotes > 0) {
                    const exiledId = tiedPlayers[0];
                    const exiledPlayer = gameState.players.find(p => p.id === exiledId);
                    if (exiledPlayer.role.name === 'ç™½ç—´' && !exiledPlayer.hasFlipped) {
                        exiledPlayer.hasFlipped = true; exiledPlayer.hasLostVote = true;
                        UIManager.log(`æŠ•ç¥¨ç»“æœï¼š${exiledId}å·ç©å®¶è¢«æ”¾é€...ä½†ä»–ç¿»å¼€äº†èº«ä»½ç‰Œï¼Œä»–æ˜¯ã€ç™½ç—´ã€‘ï¼ä»–ä¸ä¼šæ­»äº¡ï¼Œä½†å°†å¤±å»æŠ•ç¥¨æƒã€‚`);
                        this.internalLog(`ç™½ç—´ ${exiledId}å· ç¿»ç‰Œï¼Œå…äºæ­»äº¡ã€‚`);
                    } else {
                        UIManager.log(`æŠ•ç¥¨ç»“æœï¼š${exiledId}å·ç©å®¶è¢«æ”¾é€ã€‚`);
                        await this.killPlayer(exiledId, 'è¢«æŠ•ç¥¨æ”¾é€');
                    }
                } else {
                    UIManager.log("å¹³ç¥¨æˆ–æ— äººæŠ•ç¥¨ï¼Œæ— äººå‡ºå±€ã€‚");
                }
                UIManager.renderPlayers();
                if(this.checkWinCondition()) return;
                this.prepareNextNight();
            },
            prepareNextNight() {
                gameState.day++;
                UIManager.setActionButton('è¿›å…¥é»‘å¤œ', this.startNight.bind(this));
            },
            async killPlayer(playerId, reason) {
                const player = gameState.players.find(p => p.id === playerId);
                if (!player || !player.isAlive) return;
                player.isAlive = false; player.deathReason = reason;
                this.internalLog(`ç©å®¶ ${playerId}å· (${player.role.name}) å‡ºå±€ã€‚åŸå› : ${reason}.`);

                if (player.role.name === 'çŒäºº' && reason !== 'è¢«æ¯’æ€') {
                    this.internalLog(`çŒäºº ${player.id}å· æŠ€èƒ½è§¦å‘ï¼`);
                    let targetId = null;
                    const validTargets = gameState.players.filter(p => p.isAlive).map(p => p.id);
                    if(validTargets.length === 0) {
                        UIManager.log(`çŒäºº ${player.id}å· ççœ¼ï¼Œä½†åœºä¸Šå·²æ— å…¶ä»–å­˜æ´»ç©å®¶ï¼Œæ— æ³•å¼€æªã€‚`);
                        return;
                    }

                    if (player.isHuman) {
                        targetId = await this.waitForHumanSelection('çŒäººè¯·å¼€æªï¼Œé€‰æ‹©ä¸€åç©å®¶å¸¦èµ°', (id) => gameState.players.find(p => p.id === id).isAlive);
                    } else { 
                        const prompt = `ä½ æ˜¯çŒäººï¼Œä½ å‡ºå±€äº†ï¼Œç°åœ¨å¯ä»¥å¼€æªå¸¦èµ°ä¸€äººã€‚è¯·æ ¹æ®åœºä¸Šä¿¡æ¯ï¼Œé€‰æ‹©æœ€åƒç‹¼äººçš„ç©å®¶å¼€æªã€‚`;
                        targetId = await AILogic.getAIActionDecision(player, gameState, prompt, validTargets);
                    }
                    
                    UIManager.toggleNightOverlay(false);

                    if (targetId) {
                        UIManager.log(`çŒäºº ${player.id}å· å¼€æªå¸¦èµ°äº† ${targetId}å·ï¼`);
                        await this.killPlayer(targetId, 'è¢«çŒäººå¸¦èµ°');
                    } else {
                         UIManager.log(`çŒäºº ${player.id}å· æ”¾å¼ƒäº†å¼€æªã€‚`);
                    }
                }
            },
            checkWinCondition() {
                const good = gameState.players.filter(p => p.isAlive && p.role.team === 'good');
                const evil = gameState.players.filter(p => p.isAlive && p.role.team === 'evil');
                const gods = good.filter(p => p.role.name !== 'å¹³æ°‘' && p.role.name !== 'ç™½ç—´');
                const villagers = good.filter(p => p.role.name === 'å¹³æ°‘' || p.role.name === 'ç™½ç—´');
                let gameOver = false, message = "";
                if (evil.length === 0) { gameOver = true; message = "æ‰€æœ‰ç‹¼äººå·²è¢«æ”¾é€ï¼å¥½äººé˜µè¥èƒœåˆ©ï¼"; }
                else if (gods.length === 0) { gameOver = true; message = "æ‰€æœ‰ç¥èŒå·²å‡ºå±€ï¼ç‹¼äººé˜µè¥èƒœåˆ©ï¼(å± ç¥)"; }
                else if (villagers.length === 0) { gameOver = true; message = "æ‰€æœ‰å¹³æ°‘å·²å‡ºå±€ï¼ç‹¼äººé˜µè¥èƒœåˆ©ï¼(å± æ°‘)"; }
                if (gameOver) {
                    gameState.phase = 'END';
                    UIManager.log(message, 'system'); this.internalLog(`--- æ¸¸æˆç»“æŸ: ${message} ---`);
                    UIManager.updateGameInfo();
                    UIManager.setActionButton("æ¸¸æˆç»“æŸï¼Œå†æ¥ä¸€å±€?", () => location.reload());
                    this.revealAllRoles();
                }
                return gameOver;
            },
            revealAllRoles() {
                gameState.players.forEach(p => {
                    const card = document.querySelector(`.player-card[data-id='${p.id}']`);
                    if(card) {
                        const statusDiv = card.querySelector('.player-status');
                        statusDiv.textContent = p.role.name;
                        statusDiv.classList.add(p.role.team === 'good' ? 'revealed-good' : 'revealed-evil');
                    }
                });
            },
            onPlayerClick(id) {
                if (gameState.isWaitingForHumanAction && gameState.humanActionValidator(id)) {
                    UIManager.toggleNightOverlay(true, 'æ“ä½œå·²ç¡®è®¤...');
                    gameState.isWaitingForHumanAction = false;
                    gameState.humanActionResolver(id);
                } else if (gameState.phase === 'DAY_VOTE') {
                    const human = gameState.players.find(p => p.id === gameState.humanPlayerId);
                    const target = gameState.players.find(p => p.id === id);
                    if (human && human.isAlive && !human.hasLostVote && target && target.isAlive && id !== human.id) {
                        UIManager.clearSelectable();
                        this.castVote(human.id, id);
                        UIManager.setActionButton("AIæ­£åœ¨æŠ•ç¥¨...", null, false);
                        this.processAIVotes();
                    }
                }
            },
            timeout(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // --- INITIALIZE ---
        document.addEventListener('DOMContentLoaded', () => {
            GameManager.init();
        });
    </script>
</body>
</html>
